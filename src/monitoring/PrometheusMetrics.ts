/**
 * Prometheus Metrics for Validator Node
 *
 * Exposes metrics for monitoring validator performance, health, and revenue
 */

import { Registry, Counter, Gauge, Histogram, collectDefaultMetrics } from 'prom-client';
import * as http from 'http';
import { logger } from '../utils/logger';

export class PrometheusMetrics {
  private registry: Registry;
  private metricsServer?: http.Server;

  // Signature metrics
  public signaturesGenerated: Counter;
  public signaturesCompleted: Counter;
  public signaturesFailed: Counter;
  public signatureLatency: Histogram;

  // TSS metrics
  public tssParticipations: Counter;
  public tssKeySharesGenerated: Gauge;
  public partialSignaturesGenerated: Counter;
  public partialSignaturesReceived: Counter;

  // Chain monitoring metrics
  public eventsDetected: Counter;
  public eventsProcessed: Counter;
  public chainSyncHeight: Gauge;
  public chainSyncLag: Gauge;

  // Revenue metrics
  public revenueEarned: Counter;
  public revenueByChain: Counter;
  public signatureRequestsServed: Counter;

  // Health metrics
  public validatorUptime: Gauge;
  public connectedPeers: Gauge;
  public orchestratorConnected: Gauge;
  public lastSignatureTimestamp: Gauge;

  // Performance metrics
  public cpuUsage: Gauge;
  public memoryUsage: Gauge;
  public websocketConnections: Gauge;

  constructor() {
    this.registry = new Registry();

    // Collect default metrics (CPU, memory, etc.)
    collectDefaultMetrics({ register: this.registry });

    // Initialize custom metrics
    this.signaturesGenerated = new Counter({
      name: 'rapidx_signatures_generated_total',
      help: 'Total number of partial signatures generated by this validator',
      labelNames: ['chain'],
      registers: [this.registry],
    });

    this.signaturesCompleted = new Counter({
      name: 'rapidx_signatures_completed_total',
      help: 'Total number of completed TSS signatures',
      labelNames: ['source_chain', 'destination_chain'],
      registers: [this.registry],
    });

    this.signaturesFailed = new Counter({
      name: 'rapidx_signatures_failed_total',
      help: 'Total number of failed signature attempts',
      labelNames: ['reason'],
      registers: [this.registry],
    });

    this.signatureLatency = new Histogram({
      name: 'rapidx_signature_latency_seconds',
      help: 'Time taken to complete a signature',
      buckets: [0.1, 0.5, 1, 2, 5, 10],
      registers: [this.registry],
    });

    this.tssParticipations = new Counter({
      name: 'rapidx_tss_participations_total',
      help: 'Number of TSS ceremonies this validator participated in',
      registers: [this.registry],
    });

    this.tssKeySharesGenerated = new Gauge({
      name: 'rapidx_tss_keyshares_generated',
      help: 'Number of TSS key shares generated (should be 1)',
      registers: [this.registry],
    });

    this.partialSignaturesGenerated = new Counter({
      name: 'rapidx_partial_signatures_generated_total',
      help: 'Number of partial signatures generated',
      registers: [this.registry],
    });

    this.partialSignaturesReceived = new Counter({
      name: 'rapidx_partial_signatures_received_total',
      help: 'Number of partial signatures received from peers',
      labelNames: ['from_party'],
      registers: [this.registry],
    });

    this.eventsDetected = new Counter({
      name: 'rapidx_events_detected_total',
      help: 'Number of cross-chain events detected',
      labelNames: ['chain', 'event_type'],
      registers: [this.registry],
    });

    this.eventsProcessed = new Counter({
      name: 'rapidx_events_processed_total',
      help: 'Number of events successfully processed',
      labelNames: ['chain'],
      registers: [this.registry],
    });

    this.chainSyncHeight = new Gauge({
      name: 'rapidx_chain_sync_height',
      help: 'Current block height being monitored',
      labelNames: ['chain'],
      registers: [this.registry],
    });

    this.chainSyncLag = new Gauge({
      name: 'rapidx_chain_sync_lag_blocks',
      help: 'Number of blocks behind chain tip',
      labelNames: ['chain'],
      registers: [this.registry],
    });

    this.revenueEarned = new Counter({
      name: 'rapidx_revenue_earned_total',
      help: 'Total revenue earned in RAPIDX tokens',
      registers: [this.registry],
    });

    this.revenueByChain = new Counter({
      name: 'rapidx_revenue_by_chain',
      help: 'Revenue earned per chain',
      labelNames: ['source_chain', 'destination_chain'],
      registers: [this.registry],
    });

    this.signatureRequestsServed = new Counter({
      name: 'rapidx_signature_requests_served_total',
      help: 'Number of signature requests served',
      registers: [this.registry],
    });

    this.validatorUptime = new Gauge({
      name: 'rapidx_validator_uptime_seconds',
      help: 'Validator uptime in seconds',
      registers: [this.registry],
    });

    this.connectedPeers = new Gauge({
      name: 'rapidx_connected_peers',
      help: 'Number of connected peer validators',
      registers: [this.registry],
    });

    this.orchestratorConnected = new Gauge({
      name: 'rapidx_orchestrator_connected',
      help: 'Whether connected to orchestrator (1 = connected, 0 = disconnected)',
      registers: [this.registry],
    });

    this.lastSignatureTimestamp = new Gauge({
      name: 'rapidx_last_signature_timestamp',
      help: 'Unix timestamp of last completed signature',
      registers: [this.registry],
    });

    this.cpuUsage = new Gauge({
      name: 'rapidx_cpu_usage_percent',
      help: 'CPU usage percentage',
      registers: [this.registry],
    });

    this.memoryUsage = new Gauge({
      name: 'rapidx_memory_usage_bytes',
      help: 'Memory usage in bytes',
      registers: [this.registry],
    });

    this.websocketConnections = new Gauge({
      name: 'rapidx_websocket_connections',
      help: 'Number of active WebSocket connections',
      registers: [this.registry],
    });

    logger.info('âœ… Prometheus metrics initialized');
  }

  /**
   * Start metrics HTTP server
   */
  startServer(port: number = 9090): void {
    this.metricsServer = http.createServer(async (req, res) => {
      if (req.url === '/metrics') {
        res.setHeader('Content-Type', this.registry.contentType);
        res.end(await this.registry.metrics());
      } else if (req.url === '/health') {
        res.setHeader('Content-Type', 'application/json');
        res.end(JSON.stringify({
          status: 'healthy',
          uptime: process.uptime(),
          timestamp: Date.now(),
        }));
      } else {
        res.statusCode = 404;
        res.end('Not Found');
      }
    });

    this.metricsServer.listen(port, () => {
      logger.info(`ðŸ“Š Prometheus metrics server listening on http://localhost:${port}/metrics`);
    });

    // Update system metrics periodically
    this.startSystemMetricsCollection();
  }

  /**
   * Stop metrics server
   */
  stopServer(): void {
    if (this.metricsServer) {
      this.metricsServer.close();
      logger.info('Prometheus metrics server stopped');
    }
  }

  /**
   * Collect system metrics periodically
   */
  private startSystemMetricsCollection(): void {
    setInterval(() => {
      // Update uptime
      this.validatorUptime.set(process.uptime());

      // Update memory usage
      const memUsage = process.memoryUsage();
      this.memoryUsage.set(memUsage.heapUsed);

      // Update CPU usage (approximation)
      const cpuUsage = process.cpuUsage();
      const totalCPU = cpuUsage.user + cpuUsage.system;
      this.cpuUsage.set(totalCPU / 1000000); // Convert to seconds
    }, 5000); // Every 5 seconds
  }

  /**
   * Record signature generation
   */
  recordSignatureGenerated(chain: string): void {
    this.signaturesGenerated.inc({ chain });
    this.partialSignaturesGenerated.inc();
    this.tssParticipations.inc();
  }

  /**
   * Record signature completion
   */
  recordSignatureCompleted(sourceChain: string, destinationChain: string, latencySeconds: number): void {
    this.signaturesCompleted.inc({ source_chain: sourceChain, destination_chain: destinationChain });
    this.signatureLatency.observe(latencySeconds);
    this.lastSignatureTimestamp.set(Date.now() / 1000);
    this.signatureRequestsServed.inc();
  }

  /**
   * Record signature failure
   */
  recordSignatureFailed(reason: string): void {
    this.signaturesFailed.inc({ reason });
  }

  /**
   * Record event detection
   */
  recordEventDetected(chain: string, eventType: string): void {
    this.eventsDetected.inc({ chain, event_type: eventType });
  }

  /**
   * Record event processing
   */
  recordEventProcessed(chain: string): void {
    this.eventsProcessed.inc({ chain });
  }

  /**
   * Update chain sync status
   */
  updateChainSync(chain: string, currentHeight: number, tipHeight: number): void {
    this.chainSyncHeight.set({ chain }, currentHeight);
    this.chainSyncLag.set({ chain }, tipHeight - currentHeight);
  }

  /**
   * Record revenue
   */
  recordRevenue(amount: number, sourceChain: string, destinationChain: string): void {
    this.revenueEarned.inc(amount);
    this.revenueByChain.inc({ source_chain: sourceChain, destination_chain: destinationChain }, amount);
  }

  /**
   * Update orchestrator connection status
   */
  setOrchestratorConnected(connected: boolean): void {
    this.orchestratorConnected.set(connected ? 1 : 0);
  }

  /**
   * Update peer count
   */
  setPeerCount(count: number): void {
    this.connectedPeers.set(count);
  }

  /**
   * Get all metrics
   */
  async getMetrics(): Promise<string> {
    return await this.registry.metrics();
  }
}

/**
 * Alert thresholds and rules (for AlertManager)
 */
export const ALERT_RULES = `
groups:
  - name: rapidx_validator_alerts
    interval: 30s
    rules:
      # High-priority alerts
      - alert: ValidatorNotSigning
        expr: time() - rapidx_last_signature_timestamp > 3600
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Validator has not signed in over 1 hour"
          description: "Validator {{ $labels.instance }} has not generated signatures in {{ $value }} seconds"

      - alert: OrchestratorDisconnected
        expr: rapidx_orchestrator_connected == 0
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Orchestrator connection lost"
          description: "Validator {{ $labels.instance }} is disconnected from orchestrator"

      - alert: ChainSyncLagging
        expr: rapidx_chain_sync_lag_blocks > 100
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Chain sync is lagging behind"
          description: "Chain {{ $labels.chain }} is {{ $value }} blocks behind"

      - alert: HighSignatureFailureRate
        expr: rate(rapidx_signatures_failed_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High signature failure rate"
          description: "Signature failure rate is {{ $value }} per second"

      - alert: LowPeerCount
        expr: rapidx_connected_peers < 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Low peer count"
          description: "Only {{ $value }} peers connected (expected 4)"

      - alert: NoRevenueEarned
        expr: time() - (rapidx_revenue_earned_total > 0)
        for: 1h
        labels:
          severity: info
        annotations:
          summary: "No revenue earned recently"
          description: "Validator has not earned revenue in the past hour"

      # Performance alerts
      - alert: HighCPUUsage
        expr: rapidx_cpu_usage_percent > 80
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage"
          description: "CPU usage is {{ $value }}%"

      - alert: HighMemoryUsage
        expr: rapidx_memory_usage_bytes > 2000000000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage"
          description: "Memory usage is {{ $value | humanize }}B"

      - alert: SlowSignatureLatency
        expr: histogram_quantile(0.95, rate(rapidx_signature_latency_seconds_bucket[5m])) > 5
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Slow signature latency"
          description: "95th percentile signature latency is {{ $value }} seconds"
`;
