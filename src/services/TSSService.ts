/**
 * TSS (Threshold Signature Scheme) Service
 * Generates threshold signatures without reconstructing the full private key
 * Uses bnb-chain/tss-lib principles (to be implemented with Go bindings)
 */

import { schnorr } from '@noble/curves/secp256k1';
import { sha256 } from '@noble/hashes/sha256';
import { logger } from '../utils/logger';
import { EventEmitter } from 'events';

export interface TSSConfig {
  partyId: number;           // This validator's party ID (1-5)
  threshold: number;         // Required signatures (3)
  totalParties: number;      // Total validators (5)
}

export interface SigningRequest {
  requestId: string;
  txHash: string;
  sourceChain: string;
  destinationChain: string;
  message: Buffer;           // Message to sign
  participants: number[];    // Which validators should participate
}

export interface PartialSignature {
  partyId: number;
  signature: Buffer;
  publicKeyShare: Buffer;
}

export interface AggregatedSignature {
  signature: string;         // Final aggregated signature
  participants: number[];    // Which parties participated
  timestamp: number;
}

/**
 * TSS Service for threshold signature generation
 *
 * CURRENT STATUS: Simplified implementation for Phase 2
 * FUTURE: Will integrate with bnb-chain/tss-lib (Go library)
 *
 * This implementation demonstrates the flow:
 * 1. Receive signing request
 * 2. Generate partial signature with key share
 * 3. Collect partial signatures from other validators
 * 4. Aggregate into final signature
 * 5. Emit event for on-chain recording
 */
export class TSSService extends EventEmitter {
  private config: TSSConfig;
  private keyShare?: Buffer;
  private publicKeyShare?: Buffer;
  private pendingRequests: Map<string, SigningRequest> = new Map();
  private partialSignatures: Map<string, PartialSignature[]> = new Map();

  constructor(config: TSSConfig) {
    super();
    this.config = config;
  }

  /**
   * Initialize TSS service
   * In production, this would load key share from secure storage
   */
  async initialize(): Promise<void> {
    // TODO: Load key share from encrypted storage
    // For now, this is a placeholder
    logger.info(`Initializing TSS service for Party ${this.config.partyId}`);
    logger.info(`Threshold: ${this.config.threshold}/${this.config.totalParties}`);

    // In production, key share would be from DKG ceremony
    // For demo purposes, generate a valid 32-byte key (deterministic based on party ID)
    // This allows signing to work for testing without full DKG implementation
    const keyMaterial = `demo-key-share-party-${this.config.partyId}-`.padEnd(32, '0');
    this.keyShare = Buffer.from(sha256(Buffer.from(keyMaterial))); // Creates a valid 32-byte key

    // Generate corresponding public key
    const pubKey = schnorr.getPublicKey(this.keyShare);
    this.publicKeyShare = Buffer.from(pubKey);

    logger.info('TSS service initialized (using demo keys - DKG needed for production)');
  }

  /**
   * Initiate signing ceremony for a transaction
   * @param request Signing request details
   */
  async initiateSigning(request: SigningRequest): Promise<void> {
    logger.info(`Initiating TSS signing for request ${request.requestId}`);
    logger.info(`Tx: ${request.txHash}, Route: ${request.sourceChain} -> ${request.destinationChain}`);

    // Store request
    this.pendingRequests.set(request.requestId, request);

    // Check if this validator should participate
    if (!request.participants.includes(this.config.partyId)) {
      logger.info(`Party ${this.config.partyId} not selected for this signing`);
      return;
    }

    // Generate partial signature
    const partialSig = await this.generatePartialSignature(request);

    // Store our partial signature
    if (!this.partialSignatures.has(request.requestId)) {
      this.partialSignatures.set(request.requestId, []);
    }
    this.partialSignatures.get(request.requestId)!.push(partialSig);

    // Emit event for orchestrator
    this.emit('partialSignatureGenerated', {
      requestId: request.requestId,
      partyId: this.config.partyId,
      signature: partialSig,
    });

    logger.info(`Partial signature generated by Party ${this.config.partyId}`);
  }

  /**
   * Generate partial signature using this validator's key share
   * @param request Signing request
   */
  private async generatePartialSignature(request: SigningRequest): Promise<PartialSignature> {
    // Hash the message
    const messageHash = sha256(request.message);

    // In production with bnb-chain/tss-lib:
    // 1. Use key share from DKG
    // 2. Participate in multi-party signing protocol
    // 3. Generate partial signature without revealing key share

    // Simplified for Phase 2 (demonstrates flow):
    // This would be replaced with actual TSS signing
    const signature = schnorr.sign(messageHash, this.keyShare!);

    return {
      partyId: this.config.partyId,
      signature: Buffer.from(signature),
      publicKeyShare: this.publicKeyShare!,
    };
  }

  /**
   * Receive partial signature from another validator
   * @param requestId Request ID
   * @param partialSig Partial signature from another party
   */
  async receivePartialSignature(requestId: string, partialSig: PartialSignature): Promise<void> {
    if (!this.pendingRequests.has(requestId)) {
      logger.warn(`Received partial signature for unknown request: ${requestId}`);
      return;
    }

    // Store partial signature
    if (!this.partialSignatures.has(requestId)) {
      this.partialSignatures.set(requestId, []);
    }

    const signatures = this.partialSignatures.get(requestId)!;

    // Avoid duplicates
    if (signatures.some(s => s.partyId === partialSig.partyId)) {
      logger.warn(`Duplicate partial signature from Party ${partialSig.partyId}`);
      return;
    }

    signatures.push(partialSig);

    logger.info(`Received partial signature from Party ${partialSig.partyId} (${signatures.length}/${this.config.threshold})`);

    // Check if we have enough signatures to aggregate
    if (signatures.length >= this.config.threshold) {
      await this.aggregateSignatures(requestId);
    }
  }

  /**
   * Aggregate partial signatures into final signature
   * @param requestId Request ID
   */
  private async aggregateSignatures(requestId: string): Promise<void> {
    const partialSigs = this.partialSignatures.get(requestId);
    const request = this.pendingRequests.get(requestId);

    if (!partialSigs || !request) {
      logger.error(`Cannot aggregate: missing data for ${requestId}`);
      return;
    }

    logger.info(`Aggregating ${partialSigs.length} partial signatures...`);

    // In production with bnb-chain/tss-lib:
    // 1. Verify each partial signature
    // 2. Aggregate using TSS aggregation protocol
    // 3. Produce final signature that's valid for the full public key

    // Simplified for Phase 2:
    // This would be replaced with actual TSS aggregation
    const aggregatedSig: AggregatedSignature = {
      signature: partialSigs[0].signature.toString('hex'), // Would be actual aggregation
      participants: partialSigs.map(s => s.partyId),
      timestamp: Date.now(),
    };

    // Emit completion event
    this.emit('signatureComplete', {
      requestId,
      txHash: request.txHash,
      sourceChain: request.sourceChain,
      destinationChain: request.destinationChain,
      signature: aggregatedSig.signature,
      participants: aggregatedSig.participants,
    });

    // Clean up
    this.pendingRequests.delete(requestId);
    this.partialSignatures.delete(requestId);

    logger.info(`âœ… TSS signature complete for ${request.txHash}`);
    logger.info(`Participants: ${aggregatedSig.participants.join(', ')}`);
    logger.info(`Signature: ${aggregatedSig.signature.substring(0, 16)}...`);
  }

  /**
   * Verify a signature
   * @param message Message that was signed
   * @param signature Signature to verify
   * @param publicKey Public key to verify against
   */
  async verifySignature(message: Buffer, signature: string, publicKey: string): Promise<boolean> {
    try {
      const messageHash = sha256(message);
      const sigBytes = Buffer.from(signature, 'hex');
      const pubKeyBytes = Buffer.from(publicKey, 'hex');

      // In production, use TSS public key verification
      const isValid = schnorr.verify(sigBytes, messageHash, pubKeyBytes);

      logger.info(`Signature verification: ${isValid ? 'VALID' : 'INVALID'}`);

      return isValid;
    } catch (error) {
      logger.error('Signature verification failed:', error);
      return false;
    }
  }

  /**
   * Get status of pending signing requests
   */
  getPendingRequests(): string[] {
    return Array.from(this.pendingRequests.keys());
  }

  /**
   * Get collected partial signatures for a request
   */
  getPartialSignatureCount(requestId: string): number {
    return this.partialSignatures.get(requestId)?.length || 0;
  }

  /**
   * Check if this party has a key share
   */
  hasKeyShare(): boolean {
    return !!this.keyShare;
  }

  /**
   * Get public key share (for registration)
   */
  getPublicKeyShare(): Buffer | undefined {
    return this.publicKeyShare;
  }
}

/**
 * INTEGRATION NOTES FOR PRODUCTION (bnb-chain/tss-lib):
 *
 * 1. DKG (Distributed Key Generation):
 *    - Run multi-party DKG ceremony when validators register
 *    - Each validator gets a key share
 *    - Aggregated public key is stored in bridge wallet
 *    - No single party knows the full private key
 *
 * 2. Signing Protocol:
 *    - Use TSS signing ceremony (3-of-5 threshold)
 *    - Each party generates partial signature with their share
 *    - Signatures are aggregated without revealing shares
 *    - Final signature is valid for the aggregated public key
 *
 * 3. Resharing:
 *    - When validators join/leave, run resharing protocol
 *    - Generates new shares without reconstructing old key
 *    - Bridge wallet address remains the same
 *
 * 4. Go Integration:
 *    - tss-lib is written in Go
 *    - Options:
 *      a) Use child_process to call Go binary
 *      b) Use gRPC server written in Go
 *      c) Use FFI bindings (node-ffi)
 *    - Recommended: gRPC for better performance
 *
 * 5. Security:
 *    - Key shares stored in encrypted vault
 *    - HSM integration for production
 *    - Secure channel for partial signature exchange
 *    - Rate limiting on signing requests
 */
